* FraudProof

Here we aim to implement and formalize FraudProof ideas placed in L2 Setchain.

** Implementation List
*** [X] Basic Data Structures
**** [X] [[file:FraudProof/DataStructures/BTree.lean][Binary Tree]]
Small binary tree implementation plus some important definitions:

Sibilings path from an element to /the root/.
#+begin_src lean :noeval
abbrev TreePath (α : Type ):= List (Sum (BTree α) (BTree α))
#+end_src

When an element is in a tree, and moreover, we can compute its proof. In this
case, a path from the element (value) to the root.

#+begin_src lean :noeval
def valueIn [BEq α] (v : α) ( bt : BTree α ) : Bool
def valueInProof [BEq α](v : α) (bt : BTree α) : Option ( TreePath α )
#+end_src

**** [X] [[file:FraudProof/DataStructures/Value.lean][Value]]
Opaque type representing values in our data structure.

Requisites: an equilvalence relation.
**** [X] [[file:FraudProof/DataStructures/Hash.lean][ Hash]]
Hash are strings (maybe we can change that, there is a hash notion already in Lean)

It defines a hash function ~H : Value -> Hash~ and an operator ~\oplus: Hash -> Hash -> Hash~.

Moreover, we assume perfect hashing (no collisions).
#+begin_src lean :noeval
axiom hash_prop (v1 v2 : Value) : v1 ≠ v2 → H v1 ≠ H v2
#+end_src
**** [X] Merkle Tree simple data structure [[file:FraudProof/MTree.lean][MTree Implementation]]
Merkle Trees are nothing but the hash of the root of the markle tree they
represent.

Here we define important notions as hash paths. For example, a Hash is in a
Merkle tree, if we provide the /evidence/, a list of hashes and positions,
leading to the root.

#+begin_src  lean :noeval
def nodeIn (h : Hash) (path : Path) (t : MTree) : Bool
:= match t with
| MTree.node hT => listPathHashes h path == hT

#+end_src
*** [X] Games data structures
**** [X] Games
There is only one game: membership game.
Given a value (or a hash), it is an element in a given Merkle Tree.

***** [X] General Game Definitions -- [[file:FraudProof/Games/GameDef.lean][GameDefs]]
Who wins. Maybe as we define more adv games we may have more stuff here?
***** [X] One Step Game -- [[file:FraudProof/Games/OneStepGame.lean][OneStepGame]]
One step game are games over a path of length 1. That is we have
two hashes ~hb ht : Hash~ and proposers win if they can produce a /valid/
sibling hash ~hb' : Hash~, that is ~opHash hb hb' = ht~.

Other games eventually lead to this game.

***** [X] [[file:FraudProof/Games/LinearGame.lean][Linear Game]] -- [[file:FraudProof/LinearGame.lean][LinearGame]]
Linear games consist on one player proposing hashes along the one, one at a
time, and the chooser deciding if a hash is incorrect, challenging that claim.

The chooser either chooses between 'this hash is incorrect' or 'continue with
the next'. If the chooser challenges a correct hash, the chooser loses.

It can be player from the root to the leaf or the other way around.

***** [X] Log Game -- [[file:FraudProof/Games/LogGame.lean][LogGame]]

Similar to the Linear one but instead of going through the list offering one by
one, the Proposer produces the hash in the middle of the path between the leaf
and the root.
The chooser then chooses on which half the game should continue to.

It is called /Log Game/ since it halves the path at every instance. Leading to a one step game.

**** [X] Players -- [[file:FraudProof/Players.lean][Players]]
Here we define two players.
***** [X] Proposer
Proposers propose hashes along the way.
Since eventually they need to provide siblings too, proposer strategies are compose of two
arrays of hashes:
#+begin_src lean :noeval
structure HC (n : Nat) where
  -- Hashes along the way
  pathNode : Fin ( n + 1 ) -> Hash
  -- Path elem knows how to hash.
  pathSib : Fin n -> PathElem
#+end_src
Proposers are indexed on the length of the path.

Plus some operations over proposers.
****** IDEA Maybe. Min Proposer
I guess we can implement a /minimal proposer/ using just an array of hashes as
long as the path itself.
It is just taking ~pathSib~ and computing ~pathNode~. But that only works for
the ~correct player~.
***** [X] Chooser
Choosers are somewhat simpler, but I haven't proved anything on them yet.
They take three hashes and choose which side (Left or Right) they want to
continue playing in.
*** [X] Winning Players -- [[file:FraudProof/Winning/Proposer.lean][WinningDefinitions]]
The goal here was to prove that /good proposers/ always win. That is that a player with some information, in particular, the original binary tree, can compute a winning strategy.

Two main concepts:
+ What's the definition of a winning strategy?
+ How to build a winning strategy from the information /honest/ player have?

**** [X] Winning Proposer
Winning proposers are path of a given length /connecting/ two hashes.
By connecting, I mean that the proposer propose hashes (nodes and siblings) that hash correct from one hsah to the other.
We can see it better in this three props:
#+begin_src lean :noeval
@[simp]
def GoodInit (h : Hash) := Player.pathNode 0 = h

@[simp]
def GoodRoot (h : Hash ) := Player.pathNode ⟨ n , by simp ⟩ = h

@[simp]
def GoodMid  :=
    forall (m : Nat) (mLtn : m < n ),
    Player.pathNode ⟨ (m + 1) , by apply Nat.succ_lt_succ;assumption⟩ =
    opHash ( Player.pathNode ⟨ m , by apply Nat.lt_add_one_of_lt; assumption ⟩) ( Player.pathSib ⟨ m , mLtn ⟩ )
#+end_src

We also lift operations from strategies to /winning proposers/ (we'll need them
when proving.)
*** [X] Fraud Proof Games -- [[file:FraudProof.lean][FraudProofs]]
Main file proving that:
**** [X] Winning Proposers win Linear Game
**** [X] Winning Proposers win Log Game
*** [ ] Chooser Guarantees
If someone wrongly challenges a posted Merkle Tree, we can defend it and win.
It is a similar theorem to winning strategies when challenged. But on the other side.

**** [X] Main Idea: Path Skeletons
We need path skeletons to prove that choosers have winning strategies.
Theorem is like:
#+begin_quote
Following the same path provided by proposers, correct choosers know the how to
fill the same path with corrects hashes. Knowing that something is wrong, i.e.
the last hash proposed is wrong but the first is right (it is the hash of the
root assumed correct.), choosers can choose wisely when to challenge.
#+end_quote
**** [X] Linear games
Found a bug here. My bad when defining hash props.
Fixed, but I made a bug in proof evident.
**** [ ] Log Games
**** [ ] Multicut games

*** [X] Model Merkle Tree chain?
Should we model the idea of posting Merkle Trees and the possibility of challenges.

**** [X] Computing Hashes?

#+begin_src bash :noeval
python3 -m venv venv
source ./venv/bin/activate.fish

python3 -m pip install web3
#+end_src

Delegating this to Python.
#+begin_src python :noeval
from web3 import web3 # hashfunctions.

print(web3.solidity_keccak(['string'],['testing']))
#+end_src
**** [X] Removing opaque types.
See 'Hash Classes'
*** [ ] Validity Proofs
*** [X] Hash Classes
#+begin_src Lean :noeval
-- Hash function
@[class] structure Hash (α ℍ : Type) where
  mhash : α -> ℍ
-- Hash comb function
@[class] structure HashMagma (ℍ : Type) where
  comb : ℍ -> ℍ -> ℍ

-- Laws
-- Collision resistant?
@[class] structure CollResistant (α ℍ : Type)[op : Hash α ℍ] where
  -- Collision resistant? It should be hard to find these guys.
  noCollisions : forall (a b : α), a ≠ b -> op.mhash a ≠ op.mhash b

-- Similar but for magma op.
@[class] structure SLawFulHash (ℍ : Type)[m : HashMagma ℍ] where
  -- Combine diff hashes are diff.
  neqLeft : forall (a1 a2 b1 b2 : ℍ), a1 ≠ a2 -> m.comb a1 b1 ≠ m.comb a2 b2
  neqRight : forall (a1 a2 b1 b2 : ℍ), b1 ≠ b2 -> m.comb a1 b1 ≠ m.comb a2 b2

#+end_src
*** [ ] IO Interactions
**** [X] From Opaque to Classes
**** [ ] Keccak256 is a valid IO Hash?
**** [ ] IO Merkle Tree generation.
*** [ ] A bit more general games
**** [X] DAs
DAs are weird computational data.
\(\{ a : \alpha , b : \beta \}\) and a process \(f\) such that \( f(a) = b\).
**** [X] Skeletons in BTree/Tree computations.
**** [X] Implementation of winning Defensive strategy and challenging strategies.
**** [ ] Proving the above?
***** [X] DA : BTree -> Merkle Tree
***** [ ] DA : (BTree -> MTree) and Valid
****** [ ] Elements are f-Valid
****** [ ] No repeated elements


** Hash Function
Implicit assumptions.

Hash functions are:
 + Collision resistants (from RDoC)

I did not require it to prove strategies are correct when proving Merkle trees are
correct.
** Chooser Strategy.
When an invalid hash tree is detected, we can invoke a choosers strategy to
debunk the block.
The strategy operates under the assumption the top hash is wrong, otherwise
there is no way to know if the agent proposing the block is wrong. For example,
the agent can front-run another and post what it seems to be a valid block
without knowing the tree.

*** TODO Optimization: We can build players choosing shorters paths when possible.
We know the whole tree and it is not complete.


* To build the whole project
#+begin_src sh :noeval
lake build
#+end_src
