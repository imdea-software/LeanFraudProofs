<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Towards a Mechanization of Fraud Proof Games in Lean</title>
<meta name="author" content="Martín Ceresa"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal/dist/reveal.css"/>

<link rel="stylesheet" href="./reveal/dist/theme/white.css" id="theme"/>

<link rel="stylesheet" href="./custom.css"/>
<link rel="stylesheet" href="./reveal/plugin/highlight/zenburn.css"/>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h2>Towards a Mechanization of Fraud Proof Games in Lean</h2><h3>[Martín Ceresa] and César Sánchez</h3><img width="500" src="./images/white_background.png">
</section>
<section>
<section id="slide-org34b35c9">
<h2 id="org34b35c9">Introduction</h2>
<dl>
<dt>WHAT</dt><dd>A simple <b>Lean</b> mechanization of Fraud-Proof games.</dd>
<dt>GOAL</dt><dd>Prove that one honest agent guarantees <b>valid computations.</b></dd>
<dt>WHY</dt><dd>L2 Blockchains use <i>Optimistic Rollups</i> for <b>scalability.</b>
Arbitration games ensure correctness via <i>fraud proofs</i>.</dd>
<dt>HOW</dt><dd>Claims are defended and revoked through <b>authenticated data-stractures</b>.</dd>

</dl>

<aside class="notes">
<dl>
<dt>WHAT</dt><dd>Lean library.</dd>
<dt>GOAL</dt><dd>Our goal is to prove that honest players win all games.</dd>
<dt>WHY</dt><dd>Optimistic rollups based their correctness in that a single <i>honest</i>
player can guarantee correctness of the whole ecosystem.</dd>
<dt>HOW</dt><dd>(Merkle trees.)</dd>

</dl>

</aside>
</section>
<section id="slide-orgd812a2d">
<h3 id="orgd812a2d">Optimistic Rollups &#x2013; RDoC</h3>
<ul>
<li>Instead of computing everything, results are assumed correct <i>unless</i> someone
challenge them.</li>

<li>Challenges lead to <b>arbitration games</b> between proposers and challengers.</li>

<li>Fraud proofs are deterrents, not commonly executed.</li>

<li>Disputable Assertions (DAs) are registered in the blockchain</li>

<li>DAs are \(\langle f(x) = y , \mathsf{hash}(f(x) = y) \rangle \)</li>

</ul>
<aside class="notes">
<ul>
<li>Optimistic model of computations and the <i>unless</i> word here is very important.
If everything goes without troubles, nothing is computed and the L2 systems
progresses.</li>
<li>Challenges trigger arbitration games to built fraud-proofs if they can.</li>
<li>Fraudproofs are not to be played, arbitration mechanisms are deterrent mechanisms that should
be able to catch bad guys. But they are not the default mechanism.</li>
<li>DAs make a claim on the result of a computation, and they are compact
reprentations of computation.</li>

</ul>

</aside>
</section>
<section id="slide-org568edff">
<h3 id="org568edff">Arbitration Protocol</h3>
<span class="fragment"></span>
<span class="fragment"></span>
<span class="fragment"></span>
<span class="fragment"></span>
<span class="fragment"></span>
<span class="fragment"></span>
<span class="fragment"></span>

<div data-animate data-load="./DAEvol.svg">
<!--
{ "setup": [
{"element": "#g103","modifier": "attr", "parameters": [ {"class": "fragment", "data-fragment-index": "0"} ] },
{"element": "#g104","modifier": "attr", "parameters": [ {"class": "fragment", "data-fragment-index": "1"} ] },
{"element": "#g105","modifier": "attr", "parameters": [ {"class": "fragment", "data-fragment-index": "2"} ] },
{"element": "#g30","modifier": "attr", "parameters": [ {"class": "fragment", "data-fragment-index": "3"} ] },
{"element": "#g106","modifier": "attr", "parameters": [ {"class": "fragment", "data-fragment-index": "4"} ] },
{"element": "#g60","modifier": "attr", "parameters": [ {"class": "fragment", "data-fragment-index": "5"} ] },
{"element": "#g107","modifier": "attr", "parameters": [ {"class": "fragment", "data-fragment-index": "6"} ] }
]}
-->
</div>

</section>
<section>
<h3>Arbitration Protocol</h3>

<div data-animate data-load="./DAEvol.GoodProp.svg"></div>

</section>
<section>
<h3>Arbitration Protocol</h3>

<div data-animate data-load="./DAEvol.BadProp.svg"></div>
</section>
<section id="slide-orgaf30ae6">
<h4 id="orgaf30ae6">Arbitration Games</h4>
<ul>
<li>Turn-based games: one player reveals, the other explores.</li>
<li>Proposers defend their claim, challengers build fraud-proofs.</li>
<li>Games are played over Merkle trees.</li>
<li>Played until small verifiable data, done at L1.</li>
<li>Two fraud-types:
<ul>
<li>Incorrect hash (structure)</li>
<li>Incorrect data (membership)</li>

</ul></li>

</ul>

<aside class="notes">
<p>
Arbitration games is the mechanism living in the L1-blockchain. Through these
mechanisms, we should be able to translate/provide correctness from the L1 to L2.
In other words, for each possible wrong thing that can happen at L2, we should
have (at least) one way of detecting it at L1.
</p>
<ul>
<li>Two player games, perfect information? Combinatorial games?</li>
<li>Each player has a role, one defends their claim, the other tries to catch the
defender lying.</li>
<li>Games are played on <i>authenticated data-structures</i> where Merkle trees are king.
 This is very important, because by
traversing the tree, we get hashes that can be check to be the correct ones.
So end up having a chain of hashes leading to the root forming a verifiable claim: a fraud-proof or a validity proof.</li>
<li><p>
Assuming a predicate indicating valid from invalid elements, two things could go wrong:
</p>
<ul>
<li>The data-structure is incorrect, if we know the data, the top hash does not</li>

</ul>
<p>
matches our result from computing it.
</p>
<ul>
<li>There is an invalid element in the tree.</li>

</ul></li>

</ul>

</aside>
</section>
<section id="slide-org3109596">
<h3 id="org3109596">Contributions</h3>
<ul>
<li>Proved honest players always win
<ul>
<li>Proposers can defend their claims</li>
<li>Challengers can debunk false claims</li>

</ul></li>

<li>Building blocks for other L2 Schemes</li>

<li>Proved Strategies as Verified Oracles</li>

</ul>

<aside class="notes">
<p>

</p>

<ul>
<li>We proved honest players win all games.</li>
<li>We progammed and verify what we think are basic building blocks to build L2 schemes on top of Merkle-trees.</li>
<li>We can execute our strategies and use them as verified oracles. Slow when using keccak from Python.</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-orgf7630a7">
<h2 id="orgf7630a7">Formalization</h2>
<div class="outline-text-2" id="text-orgf7630a7">
</div>
</section>
<section id="slide-org7765ca0">
<h3 id="org7765ca0">Disputable Assertions</h3>
<p>
DAs are partial <code>TraceTree</code> with their hashes.
</p>

<div class="org-src-container">

<pre><code class="lean4" data-line-numbers="1-3|2|3|5-9">structure TraceTree (α β γ : Type) where
  data : BinaryTree α β
  res : γ

-- def implicit_assumption
--     (comp : TraceTree α β γ)
--     (leaf_interpretation : α -&gt; γ)
--     (node_intrepretation : β -&gt; γ -&gt; γ -&gt; γ) : Prop
--     := fold leaf_interpretation node_interpretation comp.data = comp.res
</code></pre>
</div>

<aside class="notes">
<p>
Our first step towards a modelization is to have a structure representing the
computation. Following the algorithm just described, a Binary tree is enough.
</p>

<p>
Here I call implicit assumption to the computation we want to leave outside the
blockchain, we want to leave intermediate computations and results completely
outside the blockchain.
</p>

<p>
If someone is lying about the result of a computation, depending on the
interpretation functions, we may be able to pinpoint the mistake.
</p>

</aside>
</section>
<section id="slide-org8081ab3">
<h3 id="org8081ab3">Tree Arena &#x2013; Merkle Trees</h3>
<p>
Instead of playing games exploring <i>implicit trees</i>, we made them explicit.
We define the arena of our arbitration games simply as binary trees.
</p>

<p>
Using Merkle trees, we can hash entire computations.
</p>

<div class="org-src-container">

<pre><code class="lean4" >def BTree.hash_BTree : BinaryTree α Unit -&gt; ℍ
    := fun t =&gt; t.fold hash_value comb_hash
</code></pre>
</div>

<aside class="notes">
<p>
The main basic block here is the Merkle Tree. Merkle trees are the most used
authenticated data structure and it is the foundamental stone in Optimistic Rollups.
They provide us with a way of verify statements and link reasoning arguments.
When computing the next state, agents publish a hash and the resulting state (here, we call it <code>TraceTree</code>.)
When the hashing function is collision free, the hash is a very compact way of
uniquely describing the computation that led to that result, and when an agent
publishes it, it commits to that computation. That is, when challenge, the agent can only provide hashes computing the root hash (already published.)
And thus, the agent cannot lie.
</p>

</aside>
</section>
<section id="slide-orgc80d8d3">
<h3 id="orgc80d8d3">Games : Arbitration Game</h3>
<div class="org-src-container">

<pre><code class="lean4" data-line-numbers="1|5,6|8|10,11|12">inductive ChooserMoves where | Now | ContLeft | ContRight

def treeCompArbGame
    -- Game Mechanics
    (leafCondition : α -&gt; α' -&gt; γ -&gt; Winner)
    (midCondition  : β -&gt; γ -&gt; γ -&gt; γ -&gt; Winner)
    -- Public Information
    (da : TraceTree α β γ)
    -- Players
    (revealer : BinaryTree (Option α') (Option (γ × γ)))
    (chooser : BinaryTree Unit ((β × γ × γ × γ) -&gt; Option ChooserMoves))
    : Winner := match da.data, revealer with ...
</code></pre>
</div>

<aside class="notes">
<p>
We defined the arbitration game following the scheme we just defined.
We have to conditions, one triggered when reaching leaves and one that can be
triggered by the chooser at nodes. The chooser chooses which branch of the tree to take and they can also triggers the <code>midCondition</code> at any node.
When reaching a leaf, the <code>leafCondition</code> is triggered.
</p>

<p>
So, when an agent publishes a DA, any other agent can challenge it. The
challenge consists on going through the structure of the computation, where the
proposing agent reveals information and the challenger chooses to challenge that
information or which path in the computation tree to take.
</p>

</aside>
</section>
<section id="slide-orgbbc0bbb">
<h3 id="orgbbc0bbb">Games : Membership Game</h3>
<div class="org-src-container">

<pre><code class="lean4" data-line-numbers="4-7|8-12">inductive Side : Type where | Left | Right
inductive ChooserSmp : Type where| Now | Continue

structure ElemInMTree (α ℍ : Type) where
  elem : α
  path : List Side
  mtree : ℍ

def arbElem
    (da : ElemInMTree α ℍ)
    (proposer : Side List -&gt; Option (ℍ × ℍ))
    (chooser : Side List -&gt; (ℍ × ℍ -&gt; Option ChooserSmp))
    : Winner
</code></pre>
</div>

</section>
<section>
<h3>Games : Membership Game</h3>
<ul>
<li>Variants
<ul>
<li>Linear path game (bottom-up &amp; top-down)</li>
<li>Logarithmic (bisection) game (defined using <code>treeCompArbGame</code>)</li>

</ul></li>
<li>Different variants are equivalent</li>

</ul>

<aside class="notes">
<p>
Similar to the arbitration game, here is a different game. The game consists on
proving that an element is an element of the tree.
</p>

<ul>
<li><p>
We defined different variants.
</p>
<ul>
<li>Linear games, following just a branc of the original</li>

</ul>
<p>
Merkle tree. Either starting from the root hash or from the element and its hash.
</p>
<ul>
<li>Logarithmic games, bisecting the path.</li>

</ul></li>
<li>We proved them equivalent from the point of view of honest players.
If an agent knows the data behind the Merkle tree, the agent knows where the
mistake is and can choose the correct path to catch the laying agent.</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-orge30bbea">
<h2 id="orge30bbea">Decomposing L2 Schemes</h2>
<ul>
<li>Instead of arbitrating over traces of programs, we can decompose the execution
into properties.</li>

<li>Domain Specific L2 frameworks.</li>

<li>Optimistic Rollups = Distributed Sequencer + Data Availability Committee +
State Transition Function.</li>

</ul>
</section>
<section id="slide-orgea2a0e3">
<h3 id="orgea2a0e3">Valid Batch Definition</h3>
<p>
Instead of executing transactions, we have a function telling us when a
transaction is valid and we have the following definition.
</p>

<dl>
<dt>Validity</dt><dd>Every transaction request in \(b\) is a valid
transaction request added by a client.</dd>
<dt>No Duplicates</dt><dd>No transaction request appears twice in \(b\).</dd>
<dt>IntegrityTwo</dt><dd>No transaction request in \(b\) appears in a
legal batch tag previously posted by the arranger.</dd>

</dl>

</section>
<section>
<h3>Valid Batch Definition</h3>

<p>
Instead of executing transactions, we have a function telling us when a
transaction is valid and we have the following definition.
</p>

<dl>
<dt>Validity</dt><dd>Every transaction request in \(b\) is a valid
transaction request added by a client.</dd>
<dt>No Duplicates</dt><dd>No transaction request appears twice in \(b\).</dd>
<dt><del>IntegrityTwo</del></dt><dd></dd>

<dt>Correct DA</dt><dd>Merkle tree is correct.</dd>

</dl>
</section>
<section id="slide-org0c624c7">
<h3 id="org0c624c7">Valid Batch Definition</h3>
<p>
Instead of executing transactions, we have a function telling us when a
transaction is valid and we have the following definition.
</p>

<div class="org-src-container">

<pre><code class="lean4" >def local_valid {α ℍ : Type}
  (da : BTree α × ℍ)(val_fun : α -&gt; Bool) : Prop
 -- Merkle Tree is correct
 := da.fst.hash_BTree = da.snd
 -- All elements are |val_fun| valid
 ∧ (da.fst.fold val_fun and)
 -- There are no duplicated elements.
 ∧ List.Nodup da.fst.toList
</code></pre>
</div>
</section>
<section id="slide-orge0c30d7">
<h3 id="orge0c30d7">Player Actions</h3>
<ul>
<li>Player 1 :
Proposes DAs (Valid or not) : Data x Hash</li>

<li>Player 2 :
Challenge those claims or not:
<ul>
<li>Data does not match hash.</li>
<li>There is an invalid element</li>
<li>There are duplicated elements</li>
<li>Valid batch</li>

</ul></li>

</ul>

<aside class="notes">
<p>

</p>

<div class="org-src-container">

<pre><code class="lean4" >inductive P2_Actions (α ℍ : Type)  : Type where
   | DAC (str : ABTree Unit ((ℍ × ℍ × ℍ) -&gt; Option ChooserMoves))
   | Invalid {n : Nat} (p : α)
             (seq : ISkeleton n)
             (str : Sequence n ((ℍ × ℍ × ℍ) -&gt; Option ChooserSmp))
   | Duplicate (n m : Nat)
      -- There are two paths
      (path_p : ISkeleton n) (path_q : ISkeleton m)
      -- Strategies to force proposer to show elements.
      (str_p : Sequence n ((ℍ × ℍ × ℍ) -&gt; Option ChooserSmp))
      (str_q : Sequence m ((ℍ × ℍ × ℍ) -&gt; Option ChooserSmp))
   | Ok
</code></pre>
</div>

<p>
We define (and verify) an honest player 2
</p>

</aside>
</section>
<section id="slide-org66a83af">
<h3 id="org66a83af">One honest chooser prevents invalid blocks</h3>
<div class="org-src-container">

<pre><code class="lean4" >theorem honest_chooser_valid
   [Hash α ℍ][HashMagma ℍ][InjectiveHash α ℍ][InjectiveMagma ℍ]
   (val_fun : α -&gt; Bool) (p1 : P1_Actions α ℍ)
   : linear_l2_protocol val_fun p1 (honest_chooser val_fun)
   ↔ local_valid p1.da val_fun
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-orga4a0e1a">
<h2 id="orga4a0e1a">Conclusions</h2>
<p>
In 5k lines of Lean, we
</p>
<ul>
<li>Formalize Arbitration games</li>
<li>Definitions of DA, Player, honest players</li>
<li>Membership games (bottom-up and top-down) and Logarithmic.</li>
<li>Formalized a simpler version of Optimistic Rollups.</li>
<li>TODO Executable</li>

</ul>
</section>
</section>
<section>
<section id="slide-org57160e2">
<h2 id="org57160e2">Future Work</h2>
<dl>
<dt>Generalization</dt><dd>Can we build a systems handling as much boiler-plate as possible?
What are the basic constructs we need to design arbitration games?</dd>
<dt>Problem decomposition</dt><dd>Can we find other games to decompose them in a clever way?</dd>
<dt>Domain Specific Layer-2 Framework</dt><dd><p>
Instead of arbitrating over the execution of programs, can we designed a
language to decompose Layer-2 protocols into simple games?
Are our basic constructs from before enough?
</p>
</section>
<section>
<h2>Future Work</h2></dd>
<dt>Time</dt><dd>Time is an attack vector (delay attacks.)</dd>
<dt>Layer-1 Limitation</dt><dd>Computations, one-shot games, small step verification not fitting in
L1-transactions.</dd>
<dt>Incentives &#x2013; Not modelled</dt><dd>Why players behave the way they do?</dd>

</dl>
</section>
</section>
</div>
</div>
<script src="./reveal/dist/reveal.js"></script>
<script src="./reveal/plugin/highlight/highlight.js"></script>
<script src="./reveal/plugin/notes/notes.js"></script>
<script src="./reveal/plugin/zoom/zoom.js"></script>
<script src="./reveal/plugin/math/math.js"></script>
<script src="./reveal/plugin/drawer/drawer.js"></script>
<script src="./reveal/plugin/loadcontent/plugin.js"></script>
<script src="./reveal/plugin/animate/plugin.js"></script>
<script src="lean.js"></script>
<script src="svg.min.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
width: 1200,

transition: 'none',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealHighlight, RevealNotes, RevealZoom, RevealMath, RevealDrawer, RevealLoadContent, RevealAnimate ],

// Optional libraries used to extend reveal.js
dependencies: [
]

,highlight: {beforeHighlight: hljs => {hljs.registerLanguage("lean", lean);hljs.configure({languages:["lean"]})}}, animate: { autoplay: true }});
</script>
</body>
</html>
