<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Towards a Mechanization of Fraud Proof Games in Lean</title>
<meta name="author" content="Martín Ceresa"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal/dist/reveal.css"/>

<link rel="stylesheet" href="./reveal/dist/theme/white.css" id="theme"/>

<link rel="stylesheet" href="./custom.css"/>
<link rel="stylesheet" href="./reveal/plugin/highlight/zenburn.css"/>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h2>Towards a Mechanization of Fraud Proof Games in Lean</h2><h3>[Martín Ceresa] and César Sánchez</h3><img width="500" src="./images/white_background.png">
</section>
<section>
<section id="slide-org523fbb6">
<h2 id="org523fbb6">Introduction</h2>
<dl>
<dt>WHAT</dt><dd>A simple <b>Lean</b> mechanization of arbitration games.</dd>
<dt>WHY</dt><dd>L2 Blockchains use <i>Optimistic Rollups</i> for <b>scalability.</b>
Arbitration games ensure correctness via <i>fraud proofs</i>.</dd>
<dt>HOW</dt><dd>Claims are defended and revoked through <b>authenticated data-stractures</b>.</dd>

</dl>

<aside class="notes">
<dl>
<dt>WHAT</dt><dd>Lean library.</dd>
<dt>WHY</dt><dd>Optimistic rollups based their correctness in that a single <i>honest</i>
player can guarantee correctness of the whole ecosystem.</dd>
<dt>HOW</dt><dd>(Merkle trees.)</dd>

</dl>

</aside>
</section>
<section id="slide-org6a6bb06">
<h3 id="org6a6bb06">Contributions</h3>
<ul>
<li>Proved honest players always win
<ul>
<li>Proposers can defend their claims</li>
<li>Challengers can debunk false claims</li>

</ul></li>

<li>Building blocks for L2 Schemes</li>

<li>Proved Strategies as Verified Oracles</li>

</ul>

<aside class="notes">
<p>

</p>

<ul>
<li>We proved honest players win all games.</li>
<li>We programmed and verify what we think are basic building blocks to build L2 schemes on top of Merkle-trees.</li>
<li>We can execute our strategies and use them as verified oracles. Slow when using keccak from Python.</li>

</ul>

</aside>
</section>
<section id="slide-orge7208ef">
<h3 id="orge7208ef">Optimistic Rollups</h3>
<ul>
<li>Instead of computing everything, results are assumed correct <b>unless</b> someone
challenge them.</li>

<li>Challenges lead to <b>arbitration games</b> between proposers and challengers.</li>

<li>Arbitration games are deterrents, <b>not commonly executed</b>.</li>

<li>Disputable Assertions (DAs) are registered in the blockchain.</li>

<li>DAs are \(\langle f(x) = y , \mathsf{hash}(f(x) = y) \rangle \)</li>

</ul>

<aside class="notes">
<ul>
<li>To alleviate the scalability issue, one solution is to come up with mechanisms
so we can move computation and data outside the blockchain, while keeping the
same properties of the blockchain (trusted computation.)
Optimistic rollups is one solution, where computations are optimistically
accepted <i>unless</i> someone challenge them.
There is a time period where agents can challenge computations, but if noone
says anything, the afte the period the computation is accepted.</li>
<li>Challenges trigger arbitration games to built fraud-proofs if they can.</li>
<li>The arbitration mechanisms are deterrent mechanisms that should
be able to catch bad guys. But they are not the default mechanism.</li>
<li>DAs make a claim on the result of a computation, and they are compact
reprentations of computation.</li>

</ul>

</aside>
</section>
<section id="slide-org01fc394">
<h3 id="org01fc394">Arbitration Games</h3>
<span class="fragment"></span>
<span class="fragment"></span>
<span class="fragment"></span>
<span class="fragment"></span>
<span class="fragment"></span>
<span class="fragment"></span>
<span class="fragment"></span>

<div data-animate data-load="./DAEvol.svg">
<!--
{ "setup": [
{"element": "#g103","modifier": "attr", "parameters": [ {"class": "fragment", "data-fragment-index": "0"} ] },
{"element": "#g104","modifier": "attr", "parameters": [ {"class": "fragment", "data-fragment-index": "1"} ] },
{"element": "#g105","modifier": "attr", "parameters": [ {"class": "fragment", "data-fragment-index": "2"} ] },
{"element": "#g30","modifier": "attr", "parameters": [ {"class": "fragment", "data-fragment-index": "3"} ] },
{"element": "#g106","modifier": "attr", "parameters": [ {"class": "fragment", "data-fragment-index": "4"} ] },
{"element": "#g60","modifier": "attr", "parameters": [ {"class": "fragment", "data-fragment-index": "5"} ] },
{"element": "#g107","modifier": "attr", "parameters": [ {"class": "fragment", "data-fragment-index": "6"} ] }
]}
-->
</div>

</section>
<section>
<h3>Arbitration Games</h3>

<div data-animate data-load="./DAEvol.GoodProp.svg"></div>

</section>
<section>
<h3>Arbitration Games</h3>

<div data-animate data-load="./DAEvol.BadProp.svg"></div>
</section>
<section id="slide-org1b99740">
<h3 id="org1b99740">Arbitration Games</h3>
<ul>
<li>Turn-based games: one player reveals, the other explores.</li>
<li>Proposers defend their claim, challengers build fraud-proofs.</li>
<li>Games are played over Merkle trees.</li>
<li>All verification steps are done by a L1 smart contract.</li>
<li>Two kind of frauds:
<ul>
<li>Incorrect hash (structure)</li>
<li>Incorrect data (membership)</li>

</ul></li>

</ul>

<aside class="notes">
<p>
Arbitration games is the mechanism living in the L1-blockchain. Through these
mechanisms, we should be able to translate/provide correctness from the L1 to L2.
In other words, for each possible wrong thing that can happen at L2, we should
have (at least) one way of detecting it at L1.
</p>
<ul>
<li>Two player games, perfect information? Combinatorial games?</li>
<li>Each player has a role, one defends their claim, the other tries to catch the
defender lying.</li>
<li>Games are played on <i>authenticated data-structures</i> where Merkle trees are king.
 This is very important, because by
traversing the tree, we get hashes that can be check to be the correct ones.
So end up having a chain of hashes leading to the root forming a verifiable claim: a fraud-proof or a validity proof.</li>
<li><p>
Assuming a predicate indicating valid from invalid elements, two things could go wrong:
</p>
<ul>
<li>The data-structure is incorrect, if we know the data, the top hash does not</li>

</ul>
<p>
matches our result from computing it.
</p>
<ul>
<li>There is an invalid element in the tree.</li>

</ul></li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-org29bb8d6">
<h2 id="org29bb8d6">Formalization</h2>
<div class="outline-text-2" id="text-org29bb8d6">
</div>
</section>
<section id="slide-orgc8fc36e">
<h3 id="orgc8fc36e">Disputable Assertions</h3>
<p>
DAs are partial <code>TraceTree</code> with their hashes.
</p>

<div class="org-src-container">

<pre><code class="lean4" data-line-numbers="1-3|2|3|5-9">structure TraceTree (α β γ : Type) where
  data : BinaryTree α β
  res : γ

-- def implicit_assumption
--     (comp : TraceTree α β γ)
--     (leaf_interpretation : α -&gt; γ)
--     (node_intrepretation : β -&gt; γ -&gt; γ -&gt; γ) : Prop
--     := fold leaf_interpretation node_interpretation comp.data = comp.res
</code></pre>
</div>

<aside class="notes">
<p>
Our first step towards a modelization is to have a structure representing the
computation. Following the algorithm just described, a Binary tree is enough.
</p>

<p>
Here I call implicit assumption to the computation we want to leave outside the
blockchain, we want to leave intermediate computations and results completely
outside the blockchain.
</p>

<p>
If someone is lying about the result of a computation, depending on the
interpretation functions, we may be able to pinpoint the mistake.
</p>

</aside>
</section>
<section id="slide-org035338b">
<h3 id="org035338b">Games : Arbitration Game</h3>
<div class="org-src-container">

<pre><code class="lean4" data-line-numbers="1|4,5|6-8|9-11|12">inductive ChooserMoves where | Now | ContLeft | ContRight

def treeCompArbGame
    -- Public Information
    (da : TraceTree α β γ)
    -- Game Mechanics
    (leafCondition : α -&gt; α' -&gt; γ -&gt; Winner)
    (midCondition  : β -&gt; γ -&gt; γ -&gt; γ -&gt; Winner)
    -- Players
    (revealer : BinaryTree (Option α') (Option (γ × γ)))
    (chooser : BinaryTree Unit ((β × γ × γ × γ) -&gt; Option ChooserMoves))
    : Winner := match da.data, revealer with ...
</code></pre>
</div>

<aside class="notes">
<p>
We defined the arbitration game following the scheme we just defined.
We have to conditions, one triggered when reaching leaves and one that can be
triggered by the chooser at nodes. The chooser chooses which branch of the tree to take and they can also triggers the <code>midCondition</code> at any node.
When reaching a leaf, the <code>leafCondition</code> is triggered.
</p>

<p>
So, when an agent publishes a DA, any other agent can challenge it. The
challenge consists on going through the structure of the computation, where the
proposing agent reveals information and the challenger chooses to challenge that
information or which path in the computation tree to take.
</p>

</aside>
</section>
<section id="slide-org203b595">
<h3 id="org203b595">Games : Membership Game</h3>
<div class="org-src-container">

<pre><code class="lean4" data-line-numbers="3-6|8|10-15">inductive Side : Type where | Left | Right

structure ElemInMTree (α ℍ : Type) where
  elem : α
  path : List Side
  mtree : ℍ

inductive ChooserSmp : Type where| Now | Continue

def arbElem
    (da : ElemInMTree α ℍ)
    (proposer : Side List -&gt; Option (ℍ × ℍ))
    (chooser : Side List -&gt; (ℍ × ℍ -&gt; Option ChooserSmp))
    : Winner
</code></pre>
</div>

</section>
<section>
<h3>Games : Membership Game</h3>
<ul>
<li>Variants
<ul>
<li>Linear path game (bottom-up &amp; top-down)</li>
<li>Logarithmic (bisection) game (defined using <code>treeCompArbGame</code>)</li>

</ul></li>
<li>Different variants are equivalent</li>

</ul>

<aside class="notes">
<p>
Similar to the arbitration game, here is a different game. The game consists on
proving that an element is an element of the tree.
</p>

<ul>
<li><p>
We defined different variants.
</p>
<ul>
<li>Linear games, following just a branc of the original</li>

</ul>
<p>
Merkle tree. Either starting from the root hash or from the element and its hash.
</p>
<ul>
<li>Logarithmic games, bisecting the path.</li>

</ul></li>
<li>We proved them equivalent from the point of view of honest players.
If an agent knows the data behind the Merkle tree, the agent knows where the
mistake is and can choose the correct path to catch the laying agent.</li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-org7d76794">
<h2 id="org7d76794">Decomposing L2 Schemes</h2>
<ul>
<li>Instead of arbitrating over traces of programs, we can
arbitrate over properties of specific algorithms.</li>

<li>Optimistic Rollups =
<ul>
<li>Distributed Sequencer</li>
<li>Data Availability Committee</li>
<li>State Transition Function</li>

</ul></li>

</ul>
</section>
<section id="slide-orgbd9e85f">
<h3 id="orgbd9e85f">Valid Batch Definition</h3>
<dl>
<dt>Validity</dt><dd>Every transaction request in \(b\) is a valid
transaction request added by a client.</dd>
<dt>No Duplicates</dt><dd>No transaction request appears twice in \(b\).</dd>
<dt>Integrity</dt><dd>No transaction request in \(b\) appears in a
legal batch tag previously posted by the sequencer.</dd>

</dl>

</section>
<section>
<h3>Valid Batch Definition</h3>

<dl>
<dt>Validity</dt><dd>Every transaction request in \(b\) is a valid
transaction request added by a client.</dd>
<dt>No Duplicates</dt><dd>No transaction request appears twice in \(b\).</dd>
<dt><del>Integrity</del></dt><dd></dd>

<dt>Correct DA</dt><dd>Merkle tree is correct.</dd>

</dl>

</section>
<section>
<h3>Valid Batch Definition</h3>

<div class="org-src-container">

<pre><code class="lean4" >def local_valid {α ℍ : Type}
  (da : BinaryTree α Unit × ℍ)(validity_pred : α -&gt; Bool) : Prop
 -- Merkle Tree is correct
 := da.fst.hash_BTree = da.snd
 -- All elements are |validity_pred| valid
 ∧ (da.fst.fold validity_pred and)
 -- There are no duplicated elements.
 ∧ List.Nodup da.fst.toList
</code></pre>
</div>
</section>
<section id="slide-org5e98dba">
<h3 id="org5e98dba">Player Actions</h3>
<ul>
<li>Player 1 :
Proposes DAs (Valid or not) : Data and Hash</li>

<li>Player 2 :
Challenge those claims or not:
<ul>
<li>Data does not match hash</li>
<li>There is an invalid element</li>
<li>There are duplicated elements</li>
<li>Valid batch</li>

</ul></li>

</ul>

<aside class="notes">
<p>

</p>

<div class="org-src-container">

<pre><code class="lean4" >inductive P2_Actions (α ℍ : Type)  : Type where
   | DAC (str : ABTree Unit ((ℍ × ℍ × ℍ) -&gt; Option ChooserMoves))
   | Invalid {n : Nat} (p : α)
             (seq : ISkeleton n)
             (str : Sequence n ((ℍ × ℍ × ℍ) -&gt; Option ChooserSmp))
   | Duplicate (n m : Nat)
      -- There are two paths
      (path_p : ISkeleton n) (path_q : ISkeleton m)
      -- Strategies to force proposer to show elements.
      (str_p : Sequence n ((ℍ × ℍ × ℍ) -&gt; Option ChooserSmp))
      (str_q : Sequence m ((ℍ × ℍ × ℍ) -&gt; Option ChooserSmp))
   | Ok
</code></pre>
</div>

<p>
We define (and verify) an honest player 2
</p>

</aside>
</section>
<section id="slide-orgc238438">
<h3 id="orgc238438">One honest chooser prevents invalid blocks</h3>
<div class="org-src-container">

<pre><code class="lean4" data-line-numbers="*|2|4,5">theorem honest_chooser_valid
   [Hash α ℍ][HashMagma ℍ][InjectiveHash α ℍ][InjectiveMagma ℍ]
   (validity_pred : α -&gt; Bool) (p1 : P1_Actions α ℍ)
   : linear_l2_protocol validity_pred p1 (honest_chooser validity_pred)
   ↔ local_valid p1.da validity_pred
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-orgb4c3aab">
<h2 id="orgb4c3aab">Conclusions</h2>
<ul>
<li>Formalized Arbitration games</li>
<li>Defined DA, players, honest players</li>
<li>Membership games: linear (bottom-up and top-down) and logarithmic.</li>
<li>Formalized a simpler version of Optimistic Rollups.</li>
<li>Strategies are executable</li>

</ul>
</section>
</section>
<section>
<section id="slide-org2051a8e">
<h2 id="org2051a8e">Future Work</h2>
<dl>
<dt>Domain Specific Layer-2 Framework</dt><dd>Can we designed a language to decompose Layer-2 protocols into simple games?</dd>
<dt>Add Time to the model</dt><dd>Time is an attack vector (delay attacks.)</dd>
<dt>Layer-1 Limitation</dt><dd>Small step verification not fitting in L1-transactions.</dd>
<dt>Incentives</dt><dd>Why players behave the way they do?</dd>
<dt>Multiplayer Games</dt><dd>Agents and multiplayer games, tournaments.</dd>

</dl>
</section>
</section>
</div>
</div>
<script src="./reveal/dist/reveal.js"></script>
<script src="./reveal/plugin/highlight/highlight.js"></script>
<script src="./reveal/plugin/notes/notes.js"></script>
<script src="./reveal/plugin/zoom/zoom.js"></script>
<script src="./reveal/plugin/math/math.js"></script>
<script src="./reveal/plugin/drawer/drawer.js"></script>
<script src="./reveal/plugin/loadcontent/plugin.js"></script>
<script src="./reveal/plugin/animate/plugin.js"></script>
<script src="lean.js"></script>
<script src="svg.min.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
width: 1200,

transition: 'none',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealHighlight, RevealNotes, RevealZoom, RevealMath, RevealDrawer, RevealLoadContent, RevealAnimate ],

// Optional libraries used to extend reveal.js
dependencies: [
]

,highlight: {beforeHighlight: hljs => {hljs.registerLanguage("lean", lean);hljs.configure({languages:["lean"]})}}, animate: { autoplay: true }});
</script>
</body>
</html>
