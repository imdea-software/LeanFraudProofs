<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Towards a Mechanization of Fraud Proof Games in Lean</title>
<meta name="author" content="Martín Ceresa"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal/dist/reveal.css"/>

<link rel="stylesheet" href="./reveal/dist/theme/white.css" id="theme"/>

<link rel="stylesheet" href="./custom.css"/>
<link rel="stylesheet" href="./reveal/plugin/highlight/zenburn.css"/>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h2>Towards a Mechanization of Fraud Proof Games in Lean</h2><h3>[Martín Ceresa] and César Sánchez</h3><img width="500" src="./images/white_background.png">
</section>
<section>
<section id="slide-orgdf3dc59">
<h2 id="orgdf3dc59">Introduction</h2>
<dl>
<dt>WHAT</dt><dd>A simple <i>Lean</i> mechanization of Fraud-Proof games.</dd>
<dt>GOAL</dt><dd>Prove that one honest agent guarantees <i>valid computations</i>.</dd>
<dt>WHY</dt><dd>L2 Blockchains use <i>Optimistic Rollups</i> for <b>scalability.</b>
Arbitration games ensure correctness via <i>fraud proofs</i>.</dd>
<dt>HOW</dt><dd>We focus on the structure of arguments using <i>authenticated data-structures</i>
(Merkle trees.)</dd>

</dl>

<aside class="notes">
<dl>
<dt>WHAT</dt><dd>this is about a lean library we programmed to do stuff</dd>
<dt>GOAL</dt><dd>Our goal was to prove the statement that one honest player can guarantee the correct evolution of the system.
There are some limitations to our approach, we do not measure time nor other attacks. Delay attacks and front-runnings.
Another way of saying this is that we only focus on the computational and
reasoning behind arbitration games.</dd>
<dt>WHY</dt><dd>It actually serves to several thing. First, optimistic rollups based
their correctness in that a single <i>honest</i> player can guarantee correctness
of the whole ecosystem.</dd>
<dt>HOW</dt><dd>??</dd>

</dl>

</aside>
</section>
<section id="slide-orgf922656">
<h3 id="orgf922656">Optimistic Rollups &#x2013; RDoC</h3>
<ul>
<li>Instead of computing, results are assumed correct <i>unless</i> someone challenge them.</li>

</ul>

<ul>
<li>Challenges lead to <i>arbitration games</i> between proposers and challengers.</li>

</ul>

<ul>
<li>Disputable Assertions (DAs) are registered in the blockchain : compact
representations of computations.</li>

<li>Fraud proofs are deterrents, not commonly executed.</li>

</ul>

<aside class="notes">
<ul>
<li>Optimistic model of computations and the <i>unless</i> word here is very important.</li>
<li>Challenges trigger arbitration games to built fraud-proofs if they can.</li>
<li>DAs make a claim on the result of a computation</li>
<li>It means that the arbitration mechanism is a deterrent mechanism that should
be able to catch bad guys. But they are not the default mechanism.</li>

</ul>

</aside>
</section>
<section id="slide-org61437c2">
<h3 id="org61437c2">Arbitration Games</h3>
<ul>
<li>Turn-based games: one player revels, the other explores.</li>
<li>Proposers defend their claim, challengers try to built a fraud-proof.</li>
<li>Games are played over Merkle trees.</li>
<li>Two fraud-types:
<ul>
<li>Incorrect hash (structure)</li>
<li>Incorrect data (membership)</li>

</ul></li>

</ul>

<aside class="notes">
<p>
Arbitration games is the mechanism living in the L1-blockchain. Through these
mechanisms, we should be able to translate/provide correctness from the L1 to L2.
In other words, for each possible wrong thing that can happen at L2, we should
have (at least) one way of detecting it at L1.
</p>
<ul>
<li>Two player games, perfect information? Combinatorial games?</li>
<li>Each player has a role, one defends their claim, the other tries to catch the
defender lying.</li>
<li>Games are played on <i>authenticated data-structures</i> where Merkle trees are king.
 This is very important, because by
traversing the tree, we get hashes that can be check to be the correct ones.
So end up having a chain of hashes leading to the root forming a verifiable claim: a fraud-proof or a validity proof.</li>
<li><p>
Assuming a predicate indicating valid from invalid elements, two things could go wrong:
</p>
<ul>
<li>The data-structure is incorrect, if we know the data, the top hash does not</li>

</ul>
<p>
matches our result from computing it.
</p>
<ul>
<li>There is an invalid element in the tree.</li>

</ul></li>

</ul>

</aside>
</section>
</section>
<section>
<section id="slide-orgcf6b151">
<h2 id="orgcf6b151">Formalization</h2>
<div class="outline-text-2" id="text-orgcf6b151">
</div>
</section>
<section id="slide-orgd0ff177">
<h3 id="orgd0ff177">Disputable Assertions</h3>
<p>
DAs are partial <code>TraceTree</code> with their hashes.
</p>

<div class="org-src-container">

<pre><code class="lean4" data-line-numbers="1-3|2|5-9">structure TraceTree (α β γ : Type) where
  data : BinaryTree α β
  res : γ

-- def implicit_assumption
--     (comp : TraceTree α β γ)
--     (leaf_interpretation : α -&gt; γ)
--     (node_intrepretation : β -&gt; γ -&gt; γ -&gt; γ) : Prop
--     := fold leaf_interpretation node_interpretation comp.data = comp.res
</code></pre>
</div>

<aside class="notes">
<p>
Our first step towards a modelization is to have a structure representing the
computation. Following the algorithm just described, a Binary tree is enough.
</p>

<p>
Here I call implicit assumption to the computation we want to leave outside the
blockchain, we want to leave intermediate computations and results completely
outside the blockchain.
</p>

<p>
If someone is lying about the result of a computation, depending on the
interpretation functions, we may be able to pinpoint the mistake.
</p>

</aside>
</section>
<section id="slide-org75d60f3">
<h3 id="org75d60f3">Tree Arena &#x2013; Merkle Trees</h3>
<p>
Instead of playing games exploring <i>implicit trees</i>, we made them explicit.
We define the arena of our arbitration games simply as binary trees.
</p>

<p>
Using Merkle trees, we can hash entire computations.
</p>

<div class="org-src-container">

<pre><code class="lean4" >def BTree.hash_BTree : BinaryTree α Unit -&gt; ℍ
    := fun t =&gt; t.fold hash_value comb_hash
</code></pre>
</div>

<aside class="notes">
<p>
The main basic block here is the Merkle Tree. Merkle trees are the most used
authenticated data structure and it is the foundamental stone in Optimistic Rollups.
They provide us with a way of verify statements and link reasoning arguments.
When computing the next state, agents publish a hash and the resulting state (here, we call it <code>TraceTree</code>.)
When the hashing function is collision free, the hash is a very compact way of
uniquely describing the computation that led to that result, and when an agent
publishes it, it commits to that computation. That is, when challenge, the agent can only provide hashes computing the root hash (already published.)
And thus, the agent cannot lie.
</p>

</aside>
</section>
<section id="slide-org9561551">
<h3 id="org9561551">Games : Arbitration Game</h3>
<div class="org-src-container">

<pre><code class="lean4" >inductive ChooserMoves where | Now | ContLeft | ContRight

def treeCompArbGame
    -- Game Mechanics
    (leafCondition : α -&gt; α' -&gt; γ -&gt; Winner)
    (midCondition  : β -&gt; γ -&gt; γ -&gt; γ -&gt; Winner)
    -- Public Information
    (da : TraceTree α β γ)
    -- Players
    (revealer : BinaryTree (Option α') (Option (γ × γ)))
    (chooser : BinaryTree Unit ((β × γ × γ × γ) -&gt; Option ChooserMoves))
    : Winner := match da.data, revealer with ...
</code></pre>
</div>

<aside class="notes">
<p>
We defined the arbitration game following the scheme we just defined.
We have to conditions, one triggered when reaching leaves and one that can be
triggered by the chooser at nodes. The chooser chooses which branch of the tree to take and they can also triggers the <code>midCondition</code> at any node.
When reaching a leaf, the <code>leafCondition</code> is triggered.
</p>

<p>
So, when an agent publishes a DA, any other agent can challenge it. The
challenge consists on going through the structure of the computation, where the
proposing agent reveals information and the challenger chooses to challenge that
information or which path in the computation tree to take.
</p>

</aside>
</section>
<section id="slide-org7aa5c48">
<h3 id="org7aa5c48">Games : Membership Game</h3>
<div class="org-src-container">

<pre><code class="lean4" >inductive SkElem : Type where | Left | Right
abbrev Skeleton := List SkElem

inductive ChooserSmp : Type where| Now | Continue

structure ElemInMTree (α ℍ : Type) where
  elem : α
  path : Skeleton
  mtree : ℍ

def arbElem
    (da : ElemInMTree α ℍ)
    (proposer : Skeleton -&gt; Option (ℍ × ℍ))
    (chooser : Skeleton -&gt; (ℍ × ℍ -&gt; Option ChooserSmp))
    : Winner
</code></pre>
</div>

</section>
<section>
<h3>Games : Membership Game</h3>
<ul>
<li>Variants
<ul>
<li>Linear path check (bottom-up &amp; top-down)</li>
<li>Logarithmic (bisection) game (defined using <code>treeCompArbGame</code>)</li>

</ul></li>
<li>Different games are equivalent (honest players win them all.)</li>

</ul>

<aside class="notes">
<p>
Similar to the arbitration game, here is a different game. The game consists on
proving that an element is an element of the tree.
</p>

<ul>
<li><p>
We defined different variants.
</p>
<ul>
<li>Linear games, following just a branc of the original</li>

</ul>
<p>
Merkle tree. Either starting from the root hash or from the element and its hash.
</p>
<ul>
<li>Logarithmic games, bisecting the path.</li>

</ul></li>
<li>We proved them equivalent from the point of view of honest players.
If an agent knows the data behind the Merkle tree, the agent knows where the
mistake is and can choose the correct path to catch the laying agent.</li>

</ul>

</aside>
</section>
<section id="slide-orgc628470">
<h3 id="orgc628470">Winning Conditions</h3>
<p>
Our expressions are define as folds/traversals, so to win a game, players must
win it in all possible states.
In our case, at the leaf level and node level.
</p>
</section>
</section>
<section>
<section id="slide-org9d9aa37">
<h2 id="org9d9aa37">Formal Statements Decomposition</h2>
</section>
<section id="slide-org140abfb">
<h3 id="org140abfb">Valid Block Definition</h3>
<p>
Instead of executing transactions, we have a function telling us when a
transaction is valid and we have the following definition.
</p>

<dl>
<dt>Validity</dt><dd>Every transaction request in \(b\) is a valid
transaction request added by a client.</dd>
<dt>No Duplicates</dt><dd>No transaction request appears twice in \(b\).</dd>
<dt>IntegrityTwo</dt><dd>No transaction request in \(b\) appears in a
legal batch tag previously posted by the arranger.</dd>

</dl>

</section>
<section>
<h3>Valid Block Definition</h3>

<p>
Instead of executing transactions, we have a function telling us when a
transaction is valid and we have the following definition.
</p>

<dl>
<dt>Validity</dt><dd>Every transaction request in \(b\) is a valid
transaction request added by a client.</dd>
<dt>No Duplicates</dt><dd>No transaction request appears twice in \(b\).</dd>
<dt><del>IntegrityTwo</del></dt><dd></dd>

<dt>Correct DA</dt><dd>Merkle tree is correct.</dd>

</dl>
</section>
<section id="slide-org47d271f">
<h3 id="org47d271f">Valid Block Definition</h3>
<p>
Instead of executing transactions, we have a function telling us when a
transaction is valid and we have the following definition.
</p>

<div class="org-src-container">

<pre><code class="lean4" >def local_valid {α ℍ : Type} [DecidableEq α][Hash α ℍ][HashMagma ℍ]
  (da : BTree α × ℍ)(val_fun : α -&gt; Bool) : Prop
 -- Merkle Tree is correct
 := da.fst.hash_BTree = da.snd
 -- All elements are |val_fun| valid
 ∧ (da.fst.fold val_fun and)
 -- There are no duplicated elements.
 ∧ List.Nodup da.fst.toList
</code></pre>
</div>
</section>
<section id="slide-orga12e152">
<h3 id="orga12e152">Player Actions</h3>
<ul>
<li>Player 1
Proposes DAs (Valid or not)</li>

<li>Player 2
Challenge those claims or not.</li>

</ul>

<div class="org-src-container">

<pre><code class="lean4" >inductive P2_Actions (α ℍ : Type)  : Type where
   | DAC (str : ABTree Unit ((ℍ × ℍ × ℍ) -&gt; Option ChooserMoves))
   | Invalid {n : Nat} (p : α)
             (seq : ISkeleton n)
             (str : Sequence n ((ℍ × ℍ × ℍ) -&gt; Option ChooserSmp))
   | Duplicate (n m : Nat)
      -- There are two paths
      (path_p : ISkeleton n) (path_q : ISkeleton m)
      -- Strategies to force proposer to show elements.
      (str_p : Sequence n ((ℍ × ℍ × ℍ) -&gt; Option ChooserSmp))
      (str_q : Sequence m ((ℍ × ℍ × ℍ) -&gt; Option ChooserSmp))
   | Ok
</code></pre>
</div>

<p>
We define (and verify) an honest player 2
</p>
</section>
<section id="slide-org831c2f7">
<h3 id="org831c2f7">One honest chooser prevents invalid blocks</h3>
<div class="org-src-container">

<pre><code class="lean4" >theorem honest_chooser_valid
   [o : Hash α ℍ][m : HashMagma ℍ][InjectiveHash α ℍ][InjectiveMagma ℍ]
   (val_fun : α -&gt; Bool) (p1 : P1_Actions α ℍ)
   : linear_l2_protocol val_fun p1 (honest_chooser val_fun)
   ↔ local_valid p1.da val_fun
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-orgdc2059e">
<h2 id="orgdc2059e">Conclusions</h2>
<p>
In 5k lines of Lean, we
</p>
<ul>
<li>Formalize Arbitration games</li>
<li>Definitions of DA, Player, honest players</li>
<li>Membership games (bottom-up and top-down) and Logarithmic.</li>
<li>Formalized a simpler version of Optimistic Rollups.</li>

</ul>
</section>
</section>
<section>
<section id="slide-orgc37776b">
<h2 id="orgc37776b">Future Work</h2>
<dl>
<dt>Generalization</dt><dd>Can we build a systems handling as much as boiler-plate possible?
What are the basic constructs we need to design arbitration games?</dd>
<dt>Problem decomposition</dt><dd>Can we find other games to decompose them in a clever way?</dd>
<dt>Domain Specific for Layer-2 schemes</dt><dd><p>
Instead of arbitrating over the execution of programs, can we designed a
language to decompose Layer-2 protocols into simple games?
Are our basic constructs from before enough?
</p>
</section>
<section>
<h2>Future Work</h2></dd>
<dt>Time</dt><dd>Time is a big attack vector here, and we left it outside of the model.
Delay attacks</dd>
<dt>Layer-1 Limintations</dt><dd>Computations, one-shoot games, small step verification not fitting in
L1-transactions.</dd>

</dl>
</section>
</section>
</div>
</div>
<script src="./reveal/dist/reveal.js"></script>
<script src="./reveal/plugin/highlight/highlight.js"></script>
<script src="./reveal/plugin/notes/notes.js"></script>
<script src="./reveal/plugin/zoom/zoom.js"></script>
<script src="./reveal/plugin/math/math.js"></script>
<script src="lean.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
width: 1200,

transition: 'none',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealHighlight, RevealNotes, RevealZoom, RevealMath ],

// Optional libraries used to extend reveal.js
dependencies: [
]

,highlight: {beforeHighlight: hljs => {hljs.registerLanguage("lean", lean);hljs.configure({languages:["lean"]})}}});
</script>
</body>
</html>
