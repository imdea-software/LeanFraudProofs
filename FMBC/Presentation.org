#+REVEAL_ROOT: ./reveal/
#+TITLE: Towards a Mechanization of Fraud Proof Games in Lean
#+AUTHOR: Martín Ceresa
#+EMAIL: martin.ceresa@imdea.org
#+OPTIONS: num:nil toc:nil reveal_width:1200
#+REVEAL_TRANS: none
#+EXCLUDE_TAGS: noexport
#+REVEAL_THEME: white
#+REVEAL_ADD_PLUGIN: drawer RevealDrawer plugin/drawer/drawer.js

#+REVEAL_PLUGINS: (highlight notes zoom math)
#+REVEAL_TITLE_SLIDE: <h2>%t</h2><h3>[%a] and César Sánchez</h3><img width="500" src="./images/white_background.png">
#+REVEAL_EXTRA_CSS: ./custom.css
#+REVEAL_EXTRA_SCRIPTS: ("lean.js")
#+REVEAL_HIGHLIGHT_URL: ./highlight.js
#+REVEAL_INIT_SCRIPT: highlight: {beforeHighlight: hljs => {hljs.registerLanguage("lean", lean);hljs.configure({languages:["lean"]})}}
# #+REVEAL_EXTERNAL_PLUGINS: ( RevealDrawer )

# check https://github.com/hakimel/reveal.js/issues/2761

* Introduction
+ WHAT ::
  A simple /Lean/ mechanization of Fraud-Proof games.
+ GOAL ::
  Prove that one honest agent guarantees /valid computations/.
+ WHY ::
  L2 Blockchains use /Optimistic Rollups/ for *scalability.*
  Arbitration games ensure correctness via /fraud proofs/.
  # Provide basic building blocks to prove that /honest players/ always win and
  # guarantee correctness of /Optimistic Rollups/ Layer-2 schemes.
+ HOW ::
  We focus on the structure of arguments using /authenticated data-structures/
  (Merkle trees.)

#+BEGIN_NOTES
+ WHAT :: this is about a lean library we programmed to do stuff
+ GOAL :: Our goal was to prove the statement that one honest player can guarantee the correct evolution of the system.
  There are some limitations to our approach, we do not measure time nor other attacks. Delay attacks and front-runnings.
  Another way of saying this is that we only focus on the computational and
  reasoning behind arbitration games.
+ WHY :: It actually serves to several thing. First, optimistic rollups based
  their correctness in that a single /honest/ player can guarantee correctness
  of the whole ecosystem.
+ HOW :: ??
#+END_NOTES

# ** Layer-2
# + Problem :: Scalability.
# + Solution :: Take everything outside the blockchain.
# + Constrain :: Keep the same guarantees as the blockchain.

# #+BEGIN_NOTES
# Layer 2 solutions come to solve one problem: scalability.

# One solution was to design mechanisms to take as much as data and computations
# outside of the blockchain while keeping the same guarantees offered by the
# blockchain itself. Or at least as much as possible.
# Other solutions involve improving the blockchain itself, sharding and stuff.

# Two big extremes solutions: Optimistic Rollups and ZK-Rollups.
# #+END_NOTES

** Optimistic Rollups -- RDoC

+ Instead of computing, results are assumed correct /unless/ someone challenge them.

+ Challenges lead to /arbitration games/ between proposers and challengers.

+ Fraud proofs are deterrents, not commonly executed.

+ Disputable Assertions (DAs) are registered in the blockchain

+ DA: (Initial State, Computation, Final State)

#+REVEAL: split:t

+ Instead of computing, results are assumed correct /unless/ someone challenge them.

+ Challenges lead to /arbitration games/ between proposers and challengers.

+ Fraud proofs are deterrents, not commonly executed.

+ Disputable Assertions (DAs) are registered in the blockchain

+ DA: (+Initial State,+ Computation, Final State)

#+REVEAL: split:t

+ Instead of computing, results are assumed correct /unless/ someone challenge them.

+ Challenges lead to /arbitration games/ between proposers and challengers.

+ Fraud proofs are deterrents, not commonly executed.

+ Disputable Assertions (DAs) are registered in the blockchain

+ DA: (+Initial State,+ Sequence of Instructions, Final State)

#+BEGIN_NOTES
+ Optimistic model of computations and the /unless/ word here is very important.
  If everything goes without troubles, nothing is computed and the L2 systems
  progresses.
+ Challenges trigger arbitration games to built fraud-proofs if they can.
+ DAs make a claim on the result of a computation, and they are compact reprentations of computation.
+ Fraudproofs are not to be played, arbitration mechanisms are deterrent mechanisms that should
  be able to catch bad guys. But they are not the default mechanism.
#+END_NOTES

** Arbitration Games

+ Turn-based games: one player reveals, the other explores.
+ Proposers defend their claim, challengers build fraud-proofs.
+ Games are played over Merkle trees.
+ Two fraud-types:
  * Incorrect hash (structure)
  * Incorrect data (membership)

#+BEGIN_NOTES
Arbitration games is the mechanism living in the L1-blockchain. Through these
mechanisms, we should be able to translate/provide correctness from the L1 to L2.
In other words, for each possible wrong thing that can happen at L2, we should
have (at least) one way of detecting it at L1.
+ Two player games, perfect information? Combinatorial games?
+ Each player has a role, one defends their claim, the other tries to catch the
  defender lying.
+ Games are played on /authenticated data-structures/ where Merkle trees are king.
   This is very important, because by
  traversing the tree, we get hashes that can be check to be the correct ones.
  So end up having a chain of hashes leading to the root forming a verifiable claim: a fraud-proof or a validity proof.
+ Assuming a predicate indicating valid from invalid elements, two things could go wrong:
  * The data-structure is incorrect, if we know the data, the top hash does not
  matches our result from computing it.
  * There is an invalid element in the tree.
#+END_NOTES

# *** TODO Game Structure

# - Player One : (Instructions, Res) \to H_1
# - Player Two : Challenges
# - Player One : (Inst_{left}, Res) \to H_{left} || (Inst_{right}, Res) \to H_{right}
# - Player Two : Left
# - Player One : (Inst_{left'}, Res) \to H_{left'} || (Inst_{right'}, Res) \to H_{right'}
# - ...
# - Player One : (I, Instr,O)
# - Layer 1 contract: val(I , Instr) = O


# ** TODO Diff between Arbitrum and RDoC?
*** [WIP] Game Structure

[[./images/games.png]]

* Formalization

** Disputable Assertions

DAs are partial ~TraceTree~ with their hashes.

#+ATTR_REVEAL: :code_attribs data-line-numbers="1-3|2|5-9"
#+begin_src lean4
structure TraceTree (α β γ : Type) where
  data : BinaryTree α β
  res : γ

-- def implicit_assumption
--     (comp : TraceTree α β γ)
--     (leaf_interpretation : α -> γ)
--     (node_intrepretation : β -> γ -> γ -> γ) : Prop
--     := fold leaf_interpretation node_interpretation comp.data = comp.res
#+end_src

#+BEGIN_NOTES
Our first step towards a modelization is to have a structure representing the
computation. Following the algorithm just described, a Binary tree is enough.

Here I call implicit assumption to the computation we want to leave outside the
blockchain, we want to leave intermediate computations and results completely
outside the blockchain.

If someone is lying about the result of a computation, depending on the
interpretation functions, we may be able to pinpoint the mistake.
#+END_NOTES

** Tree Arena -- Merkle Trees

Instead of playing games exploring /implicit trees/, we made them explicit.
We define the arena of our arbitration games simply as binary trees.

Using Merkle trees, we can hash entire computations.

#+begin_src lean4
def BTree.hash_BTree : BinaryTree α Unit -> ℍ
    := fun t => t.fold hash_value comb_hash
#+end_src

#+BEGIN_NOTES
The main basic block here is the Merkle Tree. Merkle trees are the most used
authenticated data structure and it is the foundamental stone in Optimistic Rollups.
They provide us with a way of verify statements and link reasoning arguments.
When computing the next state, agents publish a hash and the resulting state (here, we call it ~TraceTree~.)
When the hashing function is collision free, the hash is a very compact way of
uniquely describing the computation that led to that result, and when an agent
publishes it, it commits to that computation. That is, when challenge, the agent can only provide hashes computing the root hash (already published.)
And thus, the agent cannot lie.
#+END_NOTES

** Games : Arbitration Game

#+begin_src lean4
inductive ChooserMoves where | Now | ContLeft | ContRight

def treeCompArbGame
    -- Game Mechanics
    (leafCondition : α -> α' -> γ -> Winner)
    (midCondition  : β -> γ -> γ -> γ -> Winner)
    -- Public Information
    (da : TraceTree α β γ)
    -- Players
    (revealer : BinaryTree (Option α') (Option (γ × γ)))
    (chooser : BinaryTree Unit ((β × γ × γ × γ) -> Option ChooserMoves))
    : Winner := match da.data, revealer with ...
#+end_src

# Winning condition: winning all possible challenges.

#+BEGIN_NOTES
We defined the arbitration game following the scheme we just defined.
We have to conditions, one triggered when reaching leaves and one that can be
triggered by the chooser at nodes. The chooser chooses which branch of the tree to take and they can also triggers the ~midCondition~ at any node.
When reaching a leaf, the ~leafCondition~ is triggered.

So, when an agent publishes a DA, any other agent can challenge it. The
challenge consists on going through the structure of the computation, where the
proposing agent reveals information and the challenger chooses to challenge that
information or which path in the computation tree to take.
#+END_NOTES

** Games : Membership Game

#+begin_src lean4
inductive SkElem : Type where | Left | Right
abbrev Skeleton := List SkElem

inductive ChooserSmp : Type where| Now | Continue

structure ElemInMTree (α ℍ : Type) where
  elem : α
  path : Skeleton
  mtree : ℍ

def arbElem
    (da : ElemInMTree α ℍ)
    (proposer : Skeleton -> Option (ℍ × ℍ))
    (chooser : Skeleton -> (ℍ × ℍ -> Option ChooserSmp))
    : Winner
#+end_src

#+REVEAL: split:t
+ Variants
  * Linear path check (bottom-up & top-down)
  * Logarithmic (bisection) game (defined using ~treeCompArbGame~)
+ Different games are equivalent (honest players win them all.)

#+BEGIN_NOTES
Similar to the arbitration game, here is a different game. The game consists on
proving that an element is an element of the tree.

+ We defined different variants.
  * Linear games, following just a branc of the original
  Merkle tree. Either starting from the root hash or from the element and its hash.
  * Logarithmic games, bisecting the path.
+ We proved them equivalent from the point of view of honest players.
  If an agent knows the data behind the Merkle tree, the agent knows where the
  mistake is and can choose the correct path to catch the laying agent.
#+END_NOTES

** Winning Conditions

Our expressions are define as folds/traversals, so to win a game, players must
win it in all possible states.
In our case, at the leaf level and node level.

* Formal Statements Decomposition

# ** Arbitrum and RDoC
# Arbitrum and RDoC arbitrates over the execution of the evaluation machine (Turing Machines or EVM)

# We worked on designing simpler games. What if we can define a L2 scheme
# Moving from arbitration over traces to clever game decomposition into simpler
# games.

# We moved the small step evolution out simplifying the problem and defining
# simpler valid block definition.

# #+BEGIN_NOTES
# We designed a some arbitration games, different from the ones designed by arbitrum and RDoc.
# This was the real motivation of this work. We wanted to have a framework to play around and prove our games correct.
# #+END_NOTES

** Valid Batch Definition

Instead of executing transactions, we have a function telling us when a
transaction is valid and we have the following definition.

+ Validity :: Every transaction request in $b$ is a valid
    transaction request added by a client.
+ No Duplicates :: No transaction request appears twice in $b$.
+ IntegrityTwo :: No transaction request in $b$ appears in a
    legal batch tag previously posted by the arranger.

#+REVEAL: split:t

Instead of executing transactions, we have a function telling us when a
transaction is valid and we have the following definition.

+ Validity :: Every transaction request in $b$ is a valid
    transaction request added by a client.
+ No Duplicates :: No transaction request appears twice in $b$.
+ +IntegrityTwo+ ::
+ Correct DA :: Merkle tree is correct.


** Valid Batch Definition

Instead of executing transactions, we have a function telling us when a
transaction is valid and we have the following definition.

#+begin_src lean4
def local_valid {α ℍ : Type} [DecidableEq α][Hash α ℍ][HashMagma ℍ]
  (da : BTree α × ℍ)(val_fun : α -> Bool) : Prop
 -- Merkle Tree is correct
 := da.fst.hash_BTree = da.snd
 -- All elements are |val_fun| valid
 ∧ (da.fst.fold val_fun and)
 -- There are no duplicated elements.
 ∧ List.Nodup da.fst.toList
#+end_src

** Player Actions

- Player 1
  Proposes DAs (Valid or not) : Data x Hash

- Player 2
  Challenge those claims or not:
  - Data does not match hash.
  - There is an invalid element
  - There are duplicated elements
  - Valid batch

#+BEGIN_NOTES

#+begin_src lean4
inductive P2_Actions (α ℍ : Type)  : Type where
   | DAC (str : ABTree Unit ((ℍ × ℍ × ℍ) -> Option ChooserMoves))
   | Invalid {n : Nat} (p : α)
             (seq : ISkeleton n)
             (str : Sequence n ((ℍ × ℍ × ℍ) -> Option ChooserSmp))
   | Duplicate (n m : Nat)
      -- There are two paths
      (path_p : ISkeleton n) (path_q : ISkeleton m)
      -- Strategies to force proposer to show elements.
      (str_p : Sequence n ((ℍ × ℍ × ℍ) -> Option ChooserSmp))
      (str_q : Sequence m ((ℍ × ℍ × ℍ) -> Option ChooserSmp))
   | Ok
#+end_src

We define (and verify) an honest player 2

#+END_NOTES

** One honest chooser prevents invalid blocks

#+begin_src lean4
theorem honest_chooser_valid
   [o : Hash α ℍ][m : HashMagma ℍ][InjectiveHash α ℍ][InjectiveMagma ℍ]
   (val_fun : α -> Bool) (p1 : P1_Actions α ℍ)
   : linear_l2_protocol val_fun p1 (honest_chooser val_fun)
   ↔ local_valid p1.da val_fun
#+end_src

* Conclusions
In 5k lines of Lean, we
+ Formalize Arbitration games
+ Definitions of DA, Player, honest players
+ Membership games (bottom-up and top-down) and Logarithmic.
+ Formalized a simpler version of Optimistic Rollups.
+ TODO Executable

* Future Work
# + One-shot :: One-shot games can be easily implemented.
+ Generalization ::
  Can we build a systems handling as much boiler-plate as possible?
  What are the basic constructs we need to design arbitration games?
+ Problem decomposition ::
  Can we find other games to decompose them in a clever way?
+ Domain Specific Layer-2 Framework ::
  Instead of arbitrating over the execution of programs, can we designed a
  language to decompose Layer-2 protocols into simple games?
  Are our basic constructs from before enough?
  #+REVEAL: split:t
+ Time ::
  Time is an attack vector (delay attacks.)
+ Layer-1 Limitation ::
  Computations, one-shot games, small step verification not fitting in
  L1-transactions.
+ Incentives -- Not modelled ::
  Why players behave the way they do?
